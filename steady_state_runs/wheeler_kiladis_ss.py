"""
Function to look at waveno spectra of omega
30/11/2017 - note - input data is generated by save_daily_data.py in python bin

"""
import matplotlib.pyplot as plt
import numpy as np
import xarray as xr
import sh
from data_handling import month_dic
from pylab import rcParams
from numpy.fft import fft
from scipy import signal 

#Constants
rearth = 6376.0e3
omega = 7.2921150e-5
beta = 2.*omega/rearth  # in units [s^-1.m^-1]

# No seasonal cycle in steady state, so can leave out this part of the detrending

def segment_data(data):
    #Select -15 to 15 lat
    lats = [data.lat[i] for i in range(len(data.lat)) if np.abs(data.lat[i]) <= 15]
    data = data.sel(lat=lats)
    #No of windows is no of 30 day periods minus the first and last, as these will never be centre of 90 day window
    n = len(data.time)/30 - 2
    #Define a DataArray and fill with the 90 day window data
    coords = [('window_no', range(n)), ('day', range(90)), ('lat', data.lat.values), ('lon', data.lon.values)]
    data_windows = xr.DataArray(np.zeros((n, 90, len(data.lat), len(data.lon))) , coords=coords)
    for i in range(n):
        data_windows[i,:,:,:] = data.omega[i*30:i*30+90,:,:]
    
    #Remove linear trend from each window
    data_detrend = signal.detrend(data_windows, axis=data_windows.get_axis_num('day')) 
    data_detrend = xr.DataArray(data_detrend, coords=data_windows.coords, dims=data_windows.dims)
    
    #Taper the start and end of each segment to prevent spectral leakage
    taperlen = 10
    data_detrend[:,:taperlen,:,:]  = data_detrend[:,:taperlen,:,:]  * (np.cos(np.linspace(-np.pi/2, 0, taperlen))**2)[np.newaxis, :, np.newaxis, np.newaxis]
    data_detrend[:,-taperlen:,:,:] = data_detrend[:,-taperlen:,:,:] * (np.cos(np.linspace(0, np.pi/2, taperlen))**2)[np.newaxis, :, np.newaxis, np.newaxis]
            
    return data_detrend





def take_ffts(data, sanity_check=False, region='tropics', sym=None):
    
    lft = fft(data, axis=-1)     # FFT in space    
    tft = fft(lft, axis=1)               # FFT in time
    
    fts = np.fft.fftshift(tft, axes=(1,-1))
    # fourier transform in numpy is defined by exp(-2pi i (kx + wt)) 
    # but we want exp(kx - wt) so need to negate the x-domain
    fts = fts[:, :, :, ::-1]
    
    if sym is None:
        fts=fts
    elif sym is 'asym':
        fts = (fts - fts[:,:,::-1,:])/2.
    elif sym is 'sym':
        fts = (fts + fts[:,:,::-1,:])/2.
        
    power = np.abs(fts)**2  # Get power
    
    if region is 'tropics':
        spectra = power.mean(0).sum(1)  # Average power over all time windows, and sum over all latitudes
    elif region is 'ntropics':
        spectra = power.mean(0)[:,5:10,:].sum(1)  # NH only
    elif region is 'stropics':
        spectra = power.mean(0)[:,0:5,:].sum(1)  # SH only

    # Get wavenumber and frequency
    nw, nk = spectra.shape
    T = len(data.day)*1.  # Number of days used for spectra
    ks = np.arange(-nk/2, nk/2)  # non-dim wavenumber and frequency
    ws = np.arange(-nw/2, nw/2)
    ws = ws/T 
    
    spectra = xr.DataArray( spectra, [('ws', ws ), ('ks', ks )] )
    
    if sanity_check:
        levels = np.arange(14.,20.,0.2)
        np.log(spectra).plot.contourf(levels=levels)
        plt.xlim(-15.,15.)
        plt.ylim(0.,np.max(spectra.ws))
        plt.show()
    
    return spectra



def background(spectra, fsteps=10, ksteps=10, sanity_check=False):
    """Uses a 1-2-1 filter to generate 'red noise' background field for a spectra (as per WK1998)
        `fsteps` is the number of times to apply the filter in the frequency direction
        `ksteps` is the number of times to apply the filter in the wavenumber direction
    
    Returns a background field of same dimensions as `spectra`.
    """
    # create a 1D 1-2-1 averaging footprint
    bgf = spectra
    for i in range(fsteps):
        # repeated application of the 1-2-1 blur filter to the spectra
        footprint = np.array([[0,1,0], [0,2,0], [0,1,0]]) / 4.0
        bgf = signal.convolve2d(bgf, footprint, mode='same', boundary='wrap')
    for i in range(ksteps):
        # repeated application of the 1-2-1 blur filter to the spectra
        footprint = np.array([[0,0,0], [1,2,1], [0,0,0]]) / 4.0
        bgf = signal.convolve2d(bgf, footprint, mode='same', boundary='wrap')
    
    bgf = xr.DataArray( bgf, spectra.coords )
    
    if sanity_check:
        levels = np.arange(14.,20.,0.2)
        np.log(bgf).plot.contourf(levels=levels)
        plt.xlim(-15.,15.)
        plt.ylim(0.,np.max(spectra['cycles_per_day']))
        plt.show()
    
    return bgf


def remove_background(spectra, spectra_total=None):
    """A simple background removal to eliminate frequency noise.
       spectra: Symmetric or antisymmetric component of spectra
       spectra_total: Sum of symmetric and antisymmetric parts"""
    if spectra_total is None:
        spectra_total = spectra
    bg = background(spectra_total, fsteps=10, ksteps=10)
    return spectra / bg
    

def kelvin_dispersion(c, ks):
    k = ks/rearth
    w = c * k
    w = w * 86400. /2. /np.pi
    return w

def rossby_gravity_dispersion(c, ws, m):
    w = ws * 2. * np.pi / 86400.
    gkp = -(beta / (2*w)) + 0.5*np.sqrt((beta/w - 2*w/c)**2 - 8*m*beta/c)
    gkm = -(beta / (2*w)) - 0.5*np.sqrt((beta/w - 2*w/c)**2 - 8*m*beta/c)
    gkp = gkp * rearth
    gkm = gkm * rearth

    return gkp, gkm

def yanai_dispersion(c, ks):
    k = ks/rearth
    w = k*c/2 + 0.5*np.sqrt(k**2*c**2 + 4*beta*c)
    w = w * 86400. /2. /np.pi
    return w
    

def plot_wavelines(clist, mlist, ax=None, nk=False):
    inwk = np.linspace(-500., 500., 2000000)
    
    if ax is None:
        ax = plt.gca()
    
    for c in clist:
        if not nk:
            w_kelvin = kelvin_dispersion(c, inwk)
            ax.plot(inwk, w_kelvin, 'k')
        
        for m in mlist:
            if m != 0:
                gkp, gkm = rossby_gravity_dispersion(c, inwk, m)
                # Gravity waves: high frequency
                ax.plot(gkp[inwk > 0.2], inwk[inwk > 0.2], 'g')
                ax.plot(gkm[inwk > 0.2], inwk[inwk > 0.2], 'g')
                # Rossby waves: low frequency
                ax.plot(gkp[inwk < 0.2], inwk[inwk < 0.2], 'r')
                ax.plot(gkm[inwk < 0.2], inwk[inwk < 0.2], 'r')
            else:
                #Yanai Wave: when m = 0 only one solution is physically relevant
                w_yanai = yanai_dispersion(c, inwk)
                ax.plot(inwk, w_yanai, 'y')
                


def plot_wheeler_kiladis(run, clist, do_omega=False):
    rcParams['figure.figsize'] = 15, 6
    rcParams['font.size'] = 25
    rcParams['text.usetex'] = True
    
    plot_dir = '/scratch/rg419/plots/steady_state_runs/'
    mkdir = sh.mkdir.bake('-p')
    mkdir(plot_dir)
    
    data = xr.open_dataset('/scratch/rg419/Data_moist/climatologies/' + run + '_omega850.0_daily.nc', decode_times=False)
    data_detrend = segment_data(data)
    
        
    spectra = take_ffts(data_detrend)
    
    spectra_asym = take_ffts(data_detrend, sym='asym')
    spectra_sym = take_ffts(data_detrend, sym='sym')
    
    spectra_nobg_a = remove_background(spectra_asym, spectra_total=(spectra_sym+spectra_asym)/2.)
    spectra_nobg_s = remove_background(spectra_sym, spectra_total=(spectra_sym+spectra_asym)/2.)
    
    #clist = np.sqrt(9.8*np.array([12.,25.,50.]))
    
    # Two subplots
    fig, (ax1, ax2) = plt.subplots(1, 2, sharey=True)
    levels = np.arange(1.,2.1,0.1)
    
    #First plot
    f1 = spectra_nobg_a.plot.contourf(
                 ax=ax1, levels = levels, cmap = 'inferno_r', add_colorbar=False, add_labels=False, extend='max')
    plot_wavelines(clist, [0, 2], ax=ax1, nk=True)
    ax1.set_xlim(-15.,15.)
    ax1.set_ylim(0.,np.max(spectra.ws))
    ax1.set_ylabel('Cycles per day')
    ax1.set_xlabel('Wavenumber')
    ax1.grid(True,linestyle=':')
    ax1.set_title('Antisymmetric modes')
    
    #Second plot
    f2 = spectra_nobg_s.plot.contourf(
                 ax=ax2, levels=levels, cmap = 'inferno_r', add_colorbar=False, add_labels=False, extend='max')
    plot_wavelines(clist, [1], ax=ax2)
    ax2.set_xlim(-15.,15.)
    ax1.set_ylim(0.,np.max(spectra.ws))
    ax2.set_xlabel('Wavenumber')
    ax2.grid(True,linestyle=':')
    ax2.set_title('Symmetric modes')    
    
    plt.subplots_adjust(right=0.95, top=0.9, bottom=0.15, hspace=0.1)
    figname = 'wk_' + run + '.pdf'
    
    plt.savefig(plot_dir+figname)
    plt.close()
    
#plot_wheeler_kiladis('ss_91.000', [10.,30.]) 
#plot_wheeler_kiladis('ss_92.000', [10.,30.]) 
#plot_wheeler_kiladis('ss_93.000', [10.,30.]) 
#plot_wheeler_kiladis('ss_94.000', [10.,30.]) 
#plot_wheeler_kiladis('ss_95.000', [10.,30.]) 
#plot_wheeler_kiladis('ss_100.000', [10.,30.]) 
#plot_wheeler_kiladis('ss_105.000', [10.,30.]) 
plot_wheeler_kiladis('qflux_0_100', [10.,30.]) 
#plot_wheeler_kiladis('qflux_0_200', [10.,30.]) 

